---
sidebar_position: 16
description: "Практика по PL/pgSQL: функции, процедуры, переменные, циклы, исключения, динамический SQL, курсоры, RETURNS TABLE"
---

import { RandomVariantButton, TaskWithVariants, CodeBlockPostgres } from "../../src/components/practicModules/practic";

# Практика: Хранимые процедуры и функции (PL/pgSQL)

<CodeBlockPostgres />

## Задание 1 — Простые функции и RETURNS TABLE

<TaskWithVariants
  taskId="proc-1-simple"
  title="Задание 1: Простые функции + RETURNS TABLE / SETOF"
  difficulty={["Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий"]}
  estimatedTime="15-30 минут"
  description="Напиши функции с разными способами возврата данных."
  variants={[
    "Функция приветствия с форматированием имени",
    "Функция расчёта НДС (с параметром ставки)",
    "Функция классификации зарплаты (junior/mid/senior)",
    "Функция получения сотрудника по ID (RETURNS employees%ROWTYPE)",
    "Функция топ-5 сотрудников по зарплате в отделе (RETURNS TABLE)",
    "Функция подсчёта заказов клиента за период (RETURNS BIGINT)",
    "Функция форматирования суммы с валютой и локалью",
    "Функция проверки существования email (RETURNS BOOLEAN)",
    "Функция генерации случайного кода заказа (RETURNS TEXT)",
    "Функция получения среднего чека по стране (RETURNS NUMERIC)",
    "Функция списка стран клиентов (RETURNS SETOF TEXT)",
    "Функция подсчёта товаров на складе дороже X (RETURNS INTEGER)"
  ]}
>

**Требования:**
- используй минимум 3 разных способа возврата: RETURNS тип, RETURNS TABLE, SETOF, OUT-параметры
- добавь атрибуты: IMMUTABLE / STABLE / STRICT где уместно
- сделай 1–2 функции с обработкой NULL / ошибок
- протестируй вызовы в SELECT

Пример:
```sql
CREATE OR REPLACE FUNCTION get_top_employees(p_limit INT DEFAULT 5)
RETURNS TABLE(emp_id INT, name TEXT, salary NUMERIC)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
        SELECT e.emp_id, e.full_name, e.salary
        FROM employees e
        ORDER BY e.salary DESC
        LIMIT p_limit;
END;
$$;

SELECT * FROM get_top_employees(3);
```
</TaskWithVariants>

## Задание 2 — Управляющие конструкции и циклы

<TaskWithVariants
  taskId="proc-2-control"
  title="Задание 2: IF/CASE, LOOP/WHILE/FOR, CONTINUE/EXIT"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="25-45 минут"
  description="Напиши функции с логикой ветвления и циклами."
  variants={[
    "Классификация заказа по сумме (small/medium/large/vip)",
    "Расчёт скидки в зависимости от количества товаров и статуса клиента",
    "Генерация отчёта по дням недели (сколько заказов в понедельник–воскресенье)",
    "Подсчёт нечётных чисел в диапазоне (FOR + CONTINUE)",
    "Факториал через рекурсию и через LOOP",
    "Повышение зарплаты сотрудникам отдела на X% с лимитом бюджета",
    "Проверка, есть ли товары дешевле средней цены категории",
    "Генерация последовательности Фибоначчи до N",
    "Обход дерева категорий (рекурсия)",
    "Расчёт среднего чека по сегментам клиентов",
    "Проверка, достиг ли клиент порога для бонуса",
    "Генерация пароля с проверкой условий (цикл + IF)"
  ]}
>

**Требования:**
- используй минимум 2–3 конструкции: IF/ELSIF/ELSE, CASE, LOOP, WHILE, FOR, CONTINUE/EXIT
- добавь хотя бы одну рекурсивную функцию (или имитацию через цикл)
- обработай краевые случаи (0, NULL, отрицательные значения)
- протестируй на разных входных данных

Пример:
```sql
CREATE OR REPLACE FUNCTION classify_order(p_amount NUMERIC)
RETURNS TEXT
LANGUAGE plpgsql
IMMUTABLE STRICT
AS $$
BEGIN
    RETURN CASE
        WHEN p_amount < 100 THEN 'Small'
        WHEN p_amount < 1000 THEN 'Medium'
        WHEN p_amount < 5000 THEN 'Large'
        ELSE 'VIP'
    END;
END;
$$;
```
</TaskWithVariants>

## Задание 3 — Исключения, динамический SQL, курсоры

<TaskWithVariants
  taskId="proc-3-advanced"
  title="Задание 3: Исключения, динамический SQL, курсоры"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="35-60 минут"
  description="Работа с ошибками, EXECUTE и построчной обработкой."
  variants={[
    "Безопасное деление с обработкой division_by_zero",
    "Функция массового обновления цен с логом ошибок",
    "Динамический поиск по любой колонке таблицы (EXECUTE + USING)",
    "Курсор для построчной обработки больших заказов",
    "Функция переноса данных из одной таблицы в другую с обработкой FK-ошибок",
    "Динамическое создание партиции по месяцу (EXECUTE)",
    "Обработка unique_violation при вставке клиента",
    "Курсор + RETURN NEXT для генерации отчёта",
    "TRY-CATCH аналог: обработка foreign_key_violation при вставке заказа",
    "Динамический подсчёт строк по любому условию (format + EXECUTE)",
    "Рекурсивный обход категорий с защитой от цикла",
    "Массовое удаление старых логов с логированием ошибок"
  ]}
>

**Требования:**
- используй EXCEPTION WHEN ... THEN
- хотя бы одна функция с динамическим SQL (format + EXECUTE ... USING)
- хотя бы одна функция с явным курсором (OPEN / FETCH / CLOSE)
- обработай минимум 2–3 вида ошибок (NO_DATA_FOUND, division_by_zero, unique_violation и т.д.)

Пример:
```sql
CREATE OR REPLACE FUNCTION safe_divide(a NUMERIC, b NUMERIC)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'Division by zero attempted';
        RETURN NULL;
END;
$$;
```
</TaskWithVariants>

## Задание 4 — Процедуры + управление транзакциями

<TaskWithVariants
  taskId="proc-4-procedure"
  title="Задание 4: Процедуры с COMMIT/ROLLBACK внутри"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="40-70 минут"
  description="Реализуй процедуры с атомарными операциями."
  variants={[
    "Массовое повышение зарплаты отделу с батчами и COMMIT каждые N строк",
    "Перенос бюджета между отделами с проверкой достаточности",
    "Очистка старых логов с COMMIT каждые 10 000 строк",
    "Импорт заказов из JSONB с обработкой ошибок по строкам",
    "Начисление бонусов сотрудникам с логом и ROLLBACK при ошибке",
    "Синхронизация остатков товаров после импорта продаж",
    "Массовое изменение статуса заказов за период",
    "Создание резервной копии таблицы с COMMIT по партиям",
    "Обновление рейтинга товаров после добавления отзывов",
    "Перенос клиентов из сегмента Basic в Standard при достижении суммы",
    "Очистка дубликатов email с сохранением самого свежего",
    "Ежедневное закрытие смены с фиксацией выручки"
  ]}
>

**Требования:**
- используй CALL (не SELECT!)
- управляй транзакциями внутри процедуры (COMMIT / ROLLBACK)
- добавь батчевую обработку + логирование
- обработай ошибки (EXCEPTION WHEN OTHERS THEN ROLLBACK;)
- протестируй на 100–1000 строках

Пример:
```sql
CREATE OR REPLACE PROCEDURE bulk_raise_salary(p_dept_id INT, p_pct NUMERIC)
LANGUAGE plpgsql
AS $$
DECLARE
    v_count INT := 0;
BEGIN
    FOR rec IN SELECT emp_id FROM employees WHERE dept_id = p_dept_id LOOP
        UPDATE employees SET salary = salary * (1 + p_pct/100) WHERE emp_id = rec.emp_id;
        v_count := v_count + 1;
        IF v_count % 100 = 0 THEN
            COMMIT;
        END IF;
    END LOOP;
    COMMIT;
END;
$$;

CALL bulk_raise_salary(1, 10);
```
</TaskWithVariants>

## Задание 5 — Итоговый проект: система бонусов / заказов / логов

<TaskWithVariants
  taskId="proc-5-final"
  title="Задание 5: Полноценная система на PL/pgSQL (итоговое)"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="90-180 минут"
  description="Создай мини-систему с бизнес-логикой в базе."
  variants={[
    "Система начисления бонусов сотрудникам по результатам месяца",
    "Автоматическая обработка заказов: проверка остатков → списание → статус",
    "Система логов с ротацией и агрегацией по уровням",
    "Управление складом: приход/расход товаров с проверкой отрицательных остатков",
    "Система уведомлений: генерация и отправка при достижении условий",
    "Расчёт рейтинга товаров после каждого отзыва + кэширование",
    "Массовый импорт клиентов с дедупликацией и логом ошибок",
    "Ежедневный отчёт по выручке + отправка в лог/таблицу",
    "Система скидок: автоматическое применение по правилам",
    "Обработка возвратов: возврат средств + обновление статуса",
    "Сегментация клиентов: пересчёт сегмента по сумме покупок",
    "Очередь задач: worker-функция с SKIP LOCKED и advisory lock"
  ]}
>

**Требования:**
- минимум 4–6 функций + 2–3 процедуры
- комбинация техник: RETURNS TABLE, курсоры, динамический SQL, исключения, батчи, COMMIT внутри процедур
- реализуй 1–2 триггера, вызывающих функции/процедуры
- добавь логирование операций (таблица logs или RAISE NOTICE)
- протестируй на 500–2000 строках (INSERT + вызовы)
- напиши документацию: что делает каждая функция/процедура

Это задание — полноценный мини-проект для портфолио или собеседования на позицию Backend / DBA.
</TaskWithVariants>

:::tip
PL/pgSQL — это когда бизнес-логика живёт в базе и не боится сетевых задержек.  
Главные правила успеха:  
1. Короткие транзакции и явные COMMIT/ROLLBACK в процедурах  
2. Обработка исключений — спасает от сюрпризов  
3. Динамический SQL — только с format('%I') и USING  
4. Курсоры и RETURN NEXT — для больших наборов данных  
5. STRICT / IMMUTABLE / SECURITY DEFINER — для безопасности и производительности
:::
