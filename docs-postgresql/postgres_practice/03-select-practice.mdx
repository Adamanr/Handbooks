---
sidebar_position: 3
description: "Практика по сложным SELECT-запросам: JOIN всех видов, подзапросы, агрегаты, LATERAL, FILTER, DISTINCT ON, UNION/EXCEPT"
---

import { RandomVariantButton, TaskWithVariants, CodeBlockGo } from "../../src/components/practicModules/practic";

# Практика: Сложные SELECT-запросы

<CodeBlockGo />

## Задание 1 — Простые JOIN + фильтры

<TaskWithVariants
  taskId="hard-select-1-join-basic"
  title="Задание 1: Базовые JOIN + WHERE"
  difficulty={["Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий"]}
  estimatedTime="10-15 минут"
  description="Напиши запрос, который будет выводить данные из твоего варианта (INNER JOIN + LEFT JOIN). Добавь фильтры по major, status, grade."
  variants={[
    "Студенты + их курсы (INNER JOIN)",
    "Все студенты + курсы, на которые записаны (LEFT JOIN)",
    "Все курсы + записанные студенты (LEFT JOIN)",
    "Студенты Информатики + их курсы (INNER JOIN)",
    "Студенты с общим баллом > 3.5 + их курсы (INNER JOIN)",
    "Курсы + количество студентов (INNER JOIN)",
    "Профессора + их курсы (INNER JOIN)",
    "Все профессора + курсы (LEFT JOIN)",
    "Студенты + их оценки 'A' или 'B' (INNER JOIN)",
    "Курсы + средний балл по экзаменам (LEFT JOIN)",
    "Студенты без курсов (LEFT JOIN + IS NULL)",
    "Курсы без студентов (LEFT JOIN + IS NULL)",
  ]}
>
  **Требования:**
  - используй `students s INNER/LEFT JOIN enrollments e ON ... JOIN courses c ON ...`
  - выводи: имя студента, название курса, оценка, статус
  - ORDER BY student_name, course_name
  - LIMIT 20 для удобства

  Пример:
  ```sql
  SELECT 
      s.first_name || ' ' || s.last_name AS student,
      c.course_name,
      e.grade,
      e.status
  FROM students s
  INNER JOIN enrollments e ON s.student_id = e.student_id
  INNER JOIN courses c ON e.course_id = c.course_id
  WHERE e.status = 'active'
  ORDER BY student, c.course_name
  LIMIT 20;
  ```
</TaskWithVariants>

## Задание 2 — Агрегаты + GROUP BY + HAVING

<TaskWithVariants
  taskId="hard-select-2-aggregate"
  title="Задание 2: Группировка и агрегаты"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="20-25 минут"
  description="Напиши запросы с GROUP BY, COUNT, AVG, MIN/MAX, STRING_AGG, FILTER, HAVING."
  variants={[
    "Средний GPA по специальностям + количество студентов",
    "Количество студентов по городам + топ-5",
    "Количество курсов по кафедрам + средний кредит",
    "Профессора + количество студентов + топ-5",
    "Курсы + количество студентов + % заполненности",
    "Специальности + % студентов с GPA > 3.7 (FILTER)",
    "Годы поступления + количество студентов + средний GPA",
    "Курсы + средний балл экзаменов + количество сдававших",
    "Профессора + список курсов (STRING_AGG)",
    "Специальности + список студентов (STRING_AGG)",
    "Курсы + % студентов, получивших A/B (FILTER)",
    "Города + количество студентов + % от общего",
  ]}
>
  **Требования:**
  - GROUP BY major / city / department / year
  - агрегаты: COUNT(*), AVG(gpa), ROUND(...,2), STRING_AGG
  - HAVING COUNT(*) > 2 / AVG(gpa) > 3.5
  - ORDER BY убыванию

  Пример:
  ```sql
  SELECT 
      major,
      COUNT(*) AS student_count,
      ROUND(AVG(gpa), 2) AS avg_gpa,
      COUNT(*) FILTER (WHERE gpa >= 3.7) AS excellent
  FROM students
  GROUP BY major
  HAVING COUNT(*) >= 2
  ORDER BY avg_gpa DESC;
  ```
</TaskWithVariants>

## Задание 3 — Подзапросы + EXISTS / NOT EXISTS

<TaskWithVariants
  taskId="hard-select-3-subquery"
  title="Задание 3: Подзапросы и EXISTS"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="25-35 минут"
  description="Используй подзапросы (IN, EXISTS, коррелированные) для фильтрации и вычислений."
  variants={[
    "Студенты с GPA выше среднего по специальности",
    "Студенты, сдавшие хотя бы один экзамен > 90%",
    "Курсы, на которые записано > 10 студентов",
    "Профессора, у которых нет студентов",
    "Студенты, не сдававшие экзамены",
    "Курсы без экзаменов",
    "Студенты, получившие A хотя бы на одном курсе",
    "Курсы, где средний балл > 80%",
    "Студенты, записанные на все курсы кафедры",
    "Профессора, ведущие > 2 курсов",
    "Студенты Москвы с GPA выше среднего по России",
    "Курсы, где все студенты получили A/B",
  ]}
>
  **Требования:**
  - минимум 3–4 варианта: IN, EXISTS, коррелированный, ANY/ALL
  - WHERE EXISTS / NOT EXISTS / > ALL / IN (SELECT ...)
  - ROUND(AVG(...), 2) где нужно

  Пример:
  ```sql
  SELECT 
      first_name || ' ' || last_name AS student,
      major,
      gpa
  FROM students s
  WHERE gpa > (
      SELECT AVG(gpa)
      FROM students s2
      WHERE s2.major = s.major
  )
  ORDER BY major, gpa DESC;
  ```
</TaskWithVariants>

## Задание 4 — LATERAL + DISTINCT ON

<TaskWithVariants
  taskId="hard-select-4-lateral-distinct"
  title="Задание 4: LATERAL JOIN + DISTINCT ON"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="35-45 минут"
  description="Используй LATERAL для топ-N и DISTINCT ON для уникальных записей."
  variants={[
    "Топ-3 студента по GPA для каждой специальности",
    "Последняя оценка каждого студента по каждому курсу",
    "Топ-2 курса по количеству студентов для каждой кафедры",
    "Последний экзамен каждого типа для каждого курса",
    "Лучший результат каждого студента на экзаменах",
    "Топ-3 профессора по количеству студентов",
    "Последняя запись на курс для каждого студента",
    "Топ-5 студентов по среднему баллу экзаменов",
    "Последний курс, на который записался студент",
    "Топ-3 курса по среднему баллу",
    "Последняя активная запись для каждого студента",
    "Топ-2 профессора по количеству курсов",
  ]}
>
  **Требования:**
  - LATERAL + LIMIT 3 / 5
  - DISTINCT ON (student_id) ORDER BY ... DESC
  - CROSS JOIN LATERAL (...) AS top

  Пример:
  ```sql
  SELECT 
      major,
      top_student.student_name,
      top_student.gpa
  FROM (
      SELECT DISTINCT ON (major) major
      FROM students
  ) m
  CROSS JOIN LATERAL (
      SELECT 
          first_name || ' ' || last_name AS student_name,
          gpa
      FROM students s
      WHERE s.major = m.major
      ORDER BY gpa DESC
      LIMIT 1
  ) AS top_student;
  ```
</TaskWithVariants>

## Задание 5 — Итоговое: Аналитический отчёт

<TaskWithVariants
  taskId="hard-select-5-report"
  title="Задание 5: Полный аналитический отчёт (итоговое)"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="45-70 минут"
  description="Создай 1 большой отчёт + 3–4 отдельных аналитических запроса по базе university."
  variants={[
    "Отчёт: успеваемость по специальностям + топ-студенты",
    "Отчёт: загрузка курсов + топ-преподаватели",
    "Отчёт: результаты экзаменов + % успеха",
    "Отчёт: география студентов + успеваемость",
    "Отчёт: динамика поступления + GPA по годам",
    "Отчёт: профессора + студенты + курсы + оценки",
    "Отчёт: топ-10 студентов по экзаменам",
    "Отчёт: курсы с низкой успеваемостью (<70%)",
    "Отчёт: студенты без экзаменов",
    "Отчёт: специальности с высоким % A/B",
    "Отчёт: динамика GPA по семестрам",
    "Отчёт: сравнение успеваемости Москва vs другие города",
  ]}
>
  **Требования:**
  - минимум 3 JOIN (INNER/LEFT)
  - GROUP BY + HAVING
  - подзапросы / EXISTS / LATERAL
  - агрегаты + FILTER / STRING_AGG / JSON_AGG
  - оформить красиво: AS student_name, ROUND(...,2)
  - ORDER BY + LIMIT 20

  Пример структуры отчёта:
  ```sql
  -- Успеваемость по специальностям
  SELECT 
      major,
      COUNT(*) AS students,
      ROUND(AVG(gpa), 3) AS avg_gpa,
      COUNT(*) FILTER (WHERE gpa >= 3.7) AS excellent,
      ROUND(100.0 * COUNT(*) FILTER (WHERE gpa >= 3.7) / COUNT(*), 1) AS excellent_pct
  FROM students
  GROUP BY major
  HAVING COUNT(*) >= 2
  ORDER BY avg_gpa DESC;
  ```

  Это задание — полноценный аналитический отчёт, который можно показать на собеседовании.
</TaskWithVariants>

:::tip
Сложные SELECT — это когда ты начинаешь думать как аналитик, а не просто как разработчик.  
JOIN + подзапросы + агрегаты + LATERAL + FILTER — это 90% всех реальных отчётов в PostgreSQL.
:::
