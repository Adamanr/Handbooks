---
sidebar_position: 12
description: "Практика по партиционированию: range, list, hash, многоуровневое, миграция, pg_partman, pruning"
---

import { RandomVariantButton, TaskWithVariants, CodeBlockPostgres } from "../../src/components/practicModules/practic";

# Практика: Партиционирование таблиц

<CodeBlockPostgres />

## Задание 1 — Простое range-партиционирование

<TaskWithVariants
  taskId="part-1-range-basic"
  title="Задание 1: Range-партиционирование по времени"
  difficulty={["Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий"]}
  estimatedTime="20-35 минут"
  description="Создай партиционированную таблицу по дате и проверь partition pruning."
  variants={[
    "Таблица логов (log_time) — месячные партиции",
    "Таблица заказов (order_date) — квартальные партиции",
    "Таблица событий (event_time) — недельные партиции",
    "Таблица метрик (measurement_time) — дневные партиции",
    "Таблица транзакций (tx_time) — месячные партиции",
    "Таблица сессий (session_start) — дневные партиции",
    "Таблица платежей (payment_date) — месячные партиции",
    "Таблица уведомлений (sent_at) — недельные партиции",
    "Таблица изменений цен (price_change_date) — месячные партиции",
    "Таблица посещений (visit_date) — месячные партиции",
    "Таблица ошибок (error_time) — дневные партиции",
    "Таблица резервных копий (backup_date) — месячные партиции"
  ]}
>

**Требования:**
- создай главную таблицу с `PARTITION BY RANGE (дата)`
- создай 4–6 партиций вручную (или функцию для автосоздания)
- вставь 100–500 тыс. тестовых строк (разные даты)
- выполни 3 запроса с `EXPLAIN ANALYZE`:
  - запрос только к одной партиции → должен сканировать одну
  - запрос к диапазону → должен сканировать нужные партиции
  - запрос без фильтра по дате → должен сканировать все
- сравни время и Buffers с непартиционированной копией таблицы

Пример:
```sql
EXPLAIN ANALYZE SELECT * FROM logs WHERE log_time BETWEEN '2025-03-01' AND '2025-03-31';
-- Должен показать: Seq Scan on logs_2025_03 (или Index Scan)
-- НЕ должен сканировать logs_2025_01, logs_2025_02 и т.д.
```
</TaskWithVariants>

## Задание 2 — List-партиционирование + DEFAULT

<TaskWithVariants
  taskId="part-2-list"
  title="Задание 2: List-партиционирование + DEFAULT-партиция"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="25-45 минут"
  description="Раздели данные по категориям / регионам / статусам."
  variants={[
    "Клиенты по стране (USA, EU, Asia, Other)",
    "Заказы по статусу (pending/processing/shipped/delivered/cancelled)",
    "Товары по категории (Electronics/Clothing/Home/Other)",
    "События по типу (login/error/payment/view/Other)",
    "Платежи по методу (card/paypal/bank/Other)",
    "Отзывы по рейтингу (1-2/3/4-5)",
    "Логи по уровню (INFO/WARNING/ERROR/Other)",
    "Сессии по устройству (mobile/desktop/tablet/Other)",
    "Транзакции по типу (deposit/withdrawal/refund/Other)",
    "Пользователи по сегменту (Premium/Standard/Basic/Other)",
    "Продукты по складу (WH1/WH2/WH3/Other)",
    "Бронирования по типу (hotel/flight/car/Other)"
  ]}
>

**Требования:**
- создай таблицу с `PARTITION BY LIST (колонка)`
- создай 3–5 именованных партиций + одну DEFAULT
- вставь данные так, чтобы часть попала в DEFAULT
- выполни запросы с фильтром по ключу → проверь pruning
- запрос без фильтра → покажет сканирование всех партиций + DEFAULT
- перемести данные из DEFAULT в правильную партицию (ATTACH/DETACH)
- создай индексы на партициях

Пример:
```sql
EXPLAIN SELECT * FROM orders_by_status WHERE status = 'shipped';
-- Должен сканировать ТОЛЬКО orders_shipping
```
</TaskWithVariants>

## Задание 3 — Hash-партиционирование + многоуровневое

<TaskWithVariants
  taskId="part-3-hash-multi"
  title="Задание 3: Hash + многоуровневое партиционирование"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="35-60 минут"
  description="Распредели нагрузку равномерно + добавь второй уровень."
  variants={[
    "Пользователи: hash по id + list по стране",
    "Сессии: hash по session_id + range по дате",
    "Транзакции: hash по tx_id + range по дате",
    "Логи: hash по user_id + range по времени",
    "Метрики: hash по sensor_id + range по времени",
    "Заказы: hash по customer_id + range по дате",
    "Отзывы: hash по product_id + range по дате",
    "Платежи: hash по payment_id + list по методу",
    "События: hash по event_id + range по времени",
    "Документы: hash по doc_id + list по типу",
    "Клиенты: hash по id + list по сегменту",
    "Товары: hash по sku + list по категории"
  ]}
>

**Требования:**
- первый уровень — HASH (4–8 партиций)
- второй уровень — RANGE или LIST (на каждой хеш-партиции)
- вставь ~200–500 тыс. строк
- проверь равномерность распределения (COUNT(*) по партиям)
- сравни план запроса с фильтром по второму уровню (должен сканировать минимум партиций)
- создай глобальный индекс на главной таблице

Пример:
```sql
EXPLAIN SELECT * FROM user_sessions WHERE session_start >= '2025-02-01' AND session_start < '2025-02-02';
-- Должен сканировать только суб-партиции за этот день во всех хеш-партициях
```
</TaskWithVariants>

## Задание 4 — Миграция существующей таблицы в партиционированную

<TaskWithVariants
  taskId="part-4-migration"
  title="Задание 4: Миграция большой таблицы в партиционированную"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="60-120 минут"
  description="Переведи обычную таблицу в партиционированную с минимальным downtime."
  variants={[
    "Таблица логов (log_time) — месячные партиции",
    "Таблица заказов (order_date) — квартальные",
    "Таблица метрик (measurement_time) — дневные",
    "Таблица транзакций (tx_time) — месячные",
    "Таблица событий (event_time) — недельные",
    "Таблица сессий (session_start) — дневные",
    "Таблица платежей (payment_date) — месячные",
    "Таблица отзывов (review_date) — месячные",
    "Таблица посещений (visit_date) — месячные",
    "Таблица изменений цен (price_change_date) — месячные",
    "Таблица уведомлений (sent_at) — недельные",
    "Таблица резервных копий (backup_date) — месячные"
  ]}
>

**Требования:**
- создай новую партиционированную таблицу `..._new`
- скопируй данные батчами (INSERT INTO ... SELECT ... LIMIT/OFFSET или по ключу)
- создай индексы, триггеры, ограничения на новой таблице
- переименуй таблицы (ALTER TABLE old RENAME TO old_backup; ALTER TABLE new RENAME TO old)
- проверь работу зависимых объектов (вью, функции)
- (бонус) реализуй миграцию с логической репликацией или ATTACH PARTITION

Пример батчевой миграции:
```sql
DO $$
DECLARE
    min_id BIGINT; max_id BIGINT; batch BIGINT := 100000;
BEGIN
    SELECT MIN(id), MAX(id) INTO min_id, max_id FROM logs_old;
    FOR i IN min_id..max_id BY batch LOOP
        INSERT INTO logs_new
        SELECT * FROM logs_old
        WHERE id >= i AND id < i + batch;
        COMMIT;
    END LOOP;
END $$;
```
</TaskWithVariants>

## Задание 5 — Итоговый проект: партиционированная система логов / заказов

<TaskWithVariants
  taskId="part-5-final"
  title="Задание 5: Полноценная партиционированная система (итоговое)"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="120-240 минут"
  description="Спроектируй и реализуй полноценную партиционированную систему."
  variants={[
    "Система логов приложения (ежедневные партиции + ротация 90 дней)",
    "Таблица заказов магазина (месячные партиции + архив)",
    "Метрики IoT-устройств (почасовые горячие + дневные архивные)",
    "Транзакции банка (месячные + хранение 7 лет)",
    "События аналитики сайта (дневные + агрегация по месяцам)",
    "Сессии пользователей (дневные горячие + месячные холодные)",
    "Платежи и возвраты (месячные + отдельно для chargeback)",
    "Отзывы и рейтинги товаров (месячные + DEFAULT)",
    "Посещения страниц сайта (дневные + еженедельная агрегация)",
    "Изменения цен товаров (месячные + история)",
    "Уведомления и рассылки (недельные + DEFAULT)",
    "Резервные копии и бэкапы (месячные + архивирование)"
  ]}
>

**Требования:**
- главная таблица + минимум 2 уровня партиционирования (range + list/hash)
- автоматическое создание партиций (функция или pg_partman)
- механизм удаления/архивирования старых партиций (drop/attach → s3/холодный диск)
- индексы на горячих и холодных партициях (разные стратегии)
- проверка partition pruning на 3–5 типичных запросах
- мониторинг размеров партиций и количества строк
- миграция тестовых данных (если нужно)
- бонус: материализованное представление для агрегированных метрик по старым данным

Это задание — полноценный продакшн-кейс для резюме или собеседования на позицию DBA / Senior Backend.
</TaskWithVariants>

:::tip
Партиционирование — это не панацея, а инструмент.  
Главные выгоды:  
- partition pruning → ускорение запросов в 5–100 раз  
- DROP/DETACH партиции → мгновенное удаление старых данных  
- меньший bloat и быстрее VACUUM/ANALYZE  
Главные ошибки:  
- неправильный ключ партиционирования  
- слишком много мелких партиций  
- UPDATE ключа партиционирования → медленный перенос строк  
- забывать про DEFAULT-партицию и мониторинг
:::
