---
sidebar_position: 5
description: "Практика по CTE и рекурсивным запросам в PostgreSQL"
---

import { RandomVariantButton, TaskWithVariants, CodeBlockPostgres } from "../../src/components/practicModules/practic";

# Практика: CTE и рекурсивные запросы

<CodeBlockPostgres />

## Задание 1 — Простые (не-рекурсивные) CTE

<TaskWithVariants
  taskId="cte-1-basic"
  title="Задание 1: Простые CTE + читаемость и переиспользование"
  difficulty={["Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий"]}
  estimatedTime="10-20 минут"
  description="Разбей запрос на 2–4 CTE, улучши читаемость, используй переиспользование."
  variants={[
    "Топ-5 продавцов по выручке за последние 90 дней",
    "Средняя зарплата по отделам + только сотрудники с зарплатой выше средней по компании",
    "Продукты с прибылью выше средней по категории",
    "Сотрудники, не назначенные ни на один активный проект",
    "Месячная динамика продаж + кумулятивная выручка",
    "Продукты, которые не продавались последние 60 дней",
    "Отделы с наибольшим количеством сотрудников на руководящих позициях",
    "Сравнение выручки по категориям товаров (Электроника vs Одежда vs Дом)",
    "Сотрудники, чья зарплата в топ-20% внутри своего отдела",
    "Проекты с превышением бюджета (сумма часов × ставка > budget)",
    "Продажи по дням недели (понедельник–воскресенье)",
    "Товары с нулевым остатком и хотя бы одной продажей"
  ]}
>

**Требования:**
- минимум 2–3 CTE
- хотя бы одно переиспользование CTE (ссылка на предыдущий CTE)
- понятные имена CTE
- итоговый SELECT с ORDER BY и LIMIT 10–20
- используй ROUND(…, 2) для денег

Пример:
```sql
WITH recent_sales AS (
    SELECT * FROM sales
    WHERE sale_date >= CURRENT_DATE - INTERVAL '90 days'
),
employee_revenue AS (
    SELECT
        employee_id,
        SUM(quantity * unit_price) AS revenue
    FROM recent_sales
    GROUP BY employee_id
)
SELECT
    e.name,
    e.department,
    ROUND(er.revenue, 2) AS total_revenue
FROM employee_revenue er
JOIN employees e ON er.employee_id = e.employee_id
ORDER BY er.revenue DESC
LIMIT 5;
```
</TaskWithVariants>

## Задание 2 — Рекурсия: иерархия сотрудников

<TaskWithVariants
  taskId="cte-2-recursive-emp"
  title="Задание 2: Дерево сотрудников (рекурсивный CTE)"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="20-35 минут"
  description="Построй иерархию сотрудников с использованием рекурсии."
  variants={[
    "Все подчинённые конкретного менеджера (включая косвенных)",
    "Путь от сотрудника до CEO (снизу вверх)",
    "Организационная структура от CEO вниз с отступами",
    "Количество прямых и косвенных подчинённых для каждого менеджера",
    "Общая зарплата команды (менеджер + все подчинённые)",
    "Средняя зарплата по уровням иерархии",
    "Сотрудники, у которых больше 3 уровней подчинения",
    "Иерархия только IT-отдела",
    "Список всех руководителей + их прямые подчинённые",
    "Сотрудники без подчинённых (листья дерева)",
    "Менеджеры, чья команда имеет среднюю зарплату выше 120000",
    "Путь подчинения для каждого сотрудника (строкой или массивом)"
  ]}
>

**Требования:**
- WITH RECURSIVE
- базовый случай + рекурсивный (UNION ALL)
- защита от циклов (массив path / visited) — обязательно!
- отступы через REPEAT('  ', level)
- ORDER BY path или path_ids

Пример:
```sql
WITH RECURSIVE hierarchy AS (
    SELECT
        employee_id, name, manager_id, 1 AS level,
        ARRAY[employee_id] AS path
    FROM employees
    WHERE manager_id IS NULL
    UNION ALL
    SELECT
        e.employee_id, e.name, e.manager_id, h.level + 1,
        h.path || e.employee_id
    FROM employees e
    JOIN hierarchy h ON e.manager_id = h.employee_id
    WHERE e.employee_id != ALL(h.path)
)
SELECT
    REPEAT('  ', level-1) || name AS structure,
    level,
    array_to_string(path, ' → ') AS reporting_line
FROM hierarchy
ORDER BY path;
```
</TaskWithVariants>

## Задание 3 — Рекурсия: дерево категорий и BOM

<TaskWithVariants
  taskId="cte-3-recursive-tree"
  title="Задание 3: Дерево категорий / Bill of Materials"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="25-40 минут"
  description="Работа с иерархией категорий или компонентов продукта."
  variants={[
    "Полный путь категорий для каждого проданного товара",
    "Все товары в категории и всех её подкатегориях",
    "Количество продуктов по каждому уровню категорий",
    "Выручка по категориям с учётом всей вложенной структуры",
    "Список всех категорий с отступами и количеством товаров",
    "Путь от подкатегории до корневой категории",
    "Категории без товаров и без подкатегорий с товарами",
    "Bill of Materials: полная стоимость компьютера",
    "Общее количество требуемых компонентов для сборки продукта",
    "Категории, в которых средняя цена товара > 30000",
    "Самая глубокая ветка категорий",
    "Товары только в листовых категориях"
  ]}
>

**Требования:**
- рекурсия по parent_category_id
- путь в виде строки ('Электроника > Смартфоны > Аксессуары')
- защита от циклов
- JOIN с products / sales где нужно

Пример:
```sql
WITH RECURSIVE cat_tree AS (
    SELECT category_id, category_name, parent_category_id,
           category_name AS full_path, 1 AS level
    FROM categories
    WHERE parent_category_id IS NULL
    UNION ALL
    SELECT c.category_id, c.category_name, c.parent_category_id,
           ct.full_path || ' > ' || c.category_name, ct.level + 1
    FROM categories c
    JOIN cat_tree ct ON c.parent_category_id = ct.category_id
)
SELECT full_path, p.product_name, p.price
FROM cat_tree ct
JOIN products p ON p.category_id = ct.category_id
ORDER BY ct.full_path, p.price DESC;
```
</TaskWithVariants>

## Задание 4 — Генерация серий (даты, числа)

<TaskWithVariants
  taskId="cte-4-series"
  title="Задание 4: Генерация последовательностей через рекурсию"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="20-35 минут"
  description="Создай календарь / последовательность и соедини с данными."
  variants={[
    "Продажи по дням с заполнением нулей за весь период",
    "Все понедельники за последний год + выручка в эти дни",
    "Ежемесячный отчёт с нулями в месяцах без продаж",
    "Генерация 100 чисел и подсчёт факториала",
    "Числа Фибоначчи до 1000000",
    "Все даты найма сотрудников + кто был нанят в этот день",
    "Заполнение пропусков в ежедневной выручке",
    "Календарь на 2025 год + количество выходных",
    "Последовательность дат проектов + статус на каждую дату",
    "Генерация тестовых интервалов по 15 минут",
    "Даты начала каждого месяца + первая продажа месяца",
    "Рекурсивный подсчёт количества продаж за каждые 7 дней"
  ]}
>

**Требования:**
- рекурсивная генерация дат / чисел
- LEFT JOIN к реальным данным
- COALESCE(…, 0) для пропусков

Пример:
```sql
WITH RECURSIVE dates AS (
    SELECT MIN(sale_date) AS dt FROM sales
    UNION ALL
    SELECT dt + 1 FROM dates WHERE dt < (SELECT MAX(sale_date) FROM sales)
)
SELECT d.dt, COALESCE(SUM(s.quantity * s.unit_price), 0) AS revenue
FROM dates d
LEFT JOIN sales s ON s.sale_date = d.dt
GROUP BY d.dt
ORDER BY d.dt;
```
</TaskWithVariants>

## Задание 5 — Итоговое: Аналитический отчёт с рекурсией

<TaskWithVariants
  taskId="cte-5-final"
  title="Задание 5: Комплексный отчёт с CTE и рекурсией"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="50-100 минут"
  description="Создай аналитический отчёт, объединяющий несколько CTE, включая хотя бы одну рекурсию."
  variants={[
    "Организационная структура + выручка каждой команды",
    "Полная иерархия категорий + выручка и маржа по веткам",
    "Отчёт по продажам за год с заполнением всех дней",
    "BOM + общая стоимость и количество компонентов продукта",
    "Дерево сотрудников + KPI (продажи / часы на проектах)",
    "Анализ проектов: бюджет vs затраты + иерархия участников",
    "Категории + топ-3 товара + динамика продаж по месяцам",
    "Сотрудники + путь подчинения + общая зарплата подчинённых",
    "Календарь продаж + сравнение с предыдущим годом",
    "Иерархия + ранжирование менеджеров по эффективности команды",
    "Полный отчёт по HR: структура + зарплатный фонд + текучесть",
    "Продукты + путь категорий + прибыльность + остатки"
  ]}
>

**Требования:**
- минимум 4–6 CTE
- хотя бы 1 рекурсивный CTE
- комбинация агрегатов, оконных функций, JOIN-ов
- красивое форматирование (ROUND, TO_CHAR, отступы)
- защита от циклов в рекурсии
- итоговый вывод — готовый к презентации / дашборду

Это задание отлично подходит для портфолио или демонстрации на собеседовании.
</TaskWithVariants>

:::tip
Рекурсия — это когда ты начинаешь думать как дерево, а не как таблица.  
Главные правила:  
1. Всегда защита от циклов (path array + проверка)  
2. Ограничение глубины (level < 20)  
3. Понятные имена CTE — это 50% успеха
:::
