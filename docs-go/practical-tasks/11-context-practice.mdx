---
sidebar_position: 12
description: "Практика по context в Go: отмена, таймауты, дедлайны, WithValue, errgroup, request-scoped данные"
---

import { RandomVariantButton, TaskWithVariants, CodeBlockGo } from "../../src/components/practicModules/practic";

# Практика: Context в Go

<CodeBlockGo />

## Задание 1 — Долгая вычислительная задача с таймаутом

<TaskWithVariants
  taskId="context-1-compute-timeout"
  title="Задание 1: Долгая вычислительная задача"
  difficulty={["Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий"]}
  estimatedTime="10-15 минут"
  description="Напиши функцию LongCompute(ctx context.Context, n int) (int64, error). Имитируй тяжёлую работу (сумма 0..n с sleep). Если контекст отменён — верни ctx.Err(). В main используй WithTimeout(2s)."
  variants={[
    "n = 1000000000 (1 млрд) → должен прерваться",
    "n = 500000000 → прерывание",
    "n = 200000000 → прерывание",
    "n = 800000000 → прерывание",
    "n = 300000000 → прерывание",
    "n = 900000000 → прерывание",
    "n = 400000000 → прерывание",
    "n = 600000000 → прерывание",
    "n = 700000000 → прерывание",
    "n = 1200000000 → прерывание",
    "n = 1500000000 → прерывание",
    "n = 2000000000 → прерывание",
  ]}
>
  **Требования:**
  - цикл `for i := 0; i < n; i++ { sum += i; select { case <-ctx.Done(): return 0, ctx.Err() ... } }`
  - в main: `ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)`
  - `defer cancel()`
  - выведи "Превышен таймаут" или результат

  Пример вывода:
  ```
  Запускаем вычисление...
  Превышен таймаут: context deadline exceeded
  ```
</TaskWithVariants>

## Задание 2 — Отмена параллельных задач по кнопке

<TaskWithVariants
  taskId="context-2-manual-cancel"
  title="Задание 2: Отмена параллельных задач"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="15-20 минут"
  description="Запусти 5 горутин, каждая считает простые числа до 1 млн. Через 3 секунды в main вызови cancel(). Горутины должны остановиться."
  variants={[
    "5 воркеров, лимит 1 млн",
    "6 воркеров, лимит 1.2 млн",
    "4 воркера, лимит 800 тыс.",
    "7 воркеров, лимит 1.5 млн",
    "3 воркера, лимит 700 тыс.",
    "8 воркеров, лимит 900 тыс.",
    "10 воркеров, лимит 2 млн",
    "5 воркеров, лимит 1.8 млн",
    "9 воркеров, лимит 1.1 млн",
    "12 воркеров, лимит 1.3 млн",
    "2 воркера, лимит 500 тыс.",
    "15 воркеров, лимит 3 млн",
  ]}
>
  **Требования:**
  - `ctx, cancel := context.WithCancel(context.Background())`
  - каждая горутина: `for i := 2; i < limit; i++ { if IsPrime(i) { select { case <-ctx.Done(): return; default: count++ } } }`
  - через `time.Sleep(3 * time.Second)` → `cancel()`
  - выведи количество найденных простых чисел до отмены

  Пример вывода:
  ```
  Воркер 1: нашёл 78498 простых до отмены
  Отмена получена: context canceled
  ```
</TaskWithVariants>

## Задание 3 — Параллельный парсинг файлов с errgroup

<TaskWithVariants
  taskId="context-3-errgroup-parse"
  title="Задание 3: Параллельный парсинг файлов"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="20-25 минут"
  description="Дан слайс имён файлов. Запусти горутины для чтения каждого файла. Собери первую ошибку через errgroup.WithContext."
  variants={[
    "Файлы: data1.txt, data2.txt, data3.txt",
    "Файлы: logs/*.log (5 файлов)",
    "Файлы: configs/*.json (8 файлов)",
    "Файлы: reports/*.csv (10 файлов)",
    "Файлы: backups/*.bak (12 файлов)",
    "Файлы: inputs/*.in (7 файлов)",
    "Файлы: outputs/*.out (9 файлов)",
    "Файлы: temp/*.tmp (6 файлов)",
    "Файлы: sources/*.src (11 файлов)",
    "Файлы: archives/*.zip (4 файла)",
    "Файлы: metrics/*.metrics (15 файлов)",
    "Файлы: traces/*.trace (13 файлов)",
  ]}
>
  **Требования:**
  - `g, ctx := errgroup.WithContext(context.Background())`
  - `ctx, cancel := context.WithTimeout(ctx, 5*time.Second)`
  - `defer cancel()`
  - каждая горутина: `os.ReadFile`, если ошибка — return err
  - в конце: `if err := g.Wait(); err != nil { ... }`

  Пример вывода:
  ```
  Успешно прочитано 5 файлов
  Ошибка: open data_missing.txt: no such file
  ```
</TaskWithVariants>

## Задание 4 — Передача trace_id через WithValue

<TaskWithVariants
  taskId="context-4-withvalue"
  title="Задание 4: Trace ID через контекст"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="15-20 минут"
  description="Создай функцию ProcessData(ctx context.Context, data string) error. Клади trace_id в контекст и доставай в вложенных функциях."
  variants={[
    "trace_id = abc123 → обработка данных",
    "trace_id = def456 → анализ лога",
    "trace_id = ghi789 → генерация отчёта",
    "trace_id = jkl012 → парсинг JSON",
    "trace_id = mno345 → валидация",
    "trace_id = pqr678 → сжатие данных",
    "trace_id = stu901 → шифрование",
    "trace_id = vwx234 → индексация",
    "trace_id = yzab567 → рендеринг",
    "trace_id = cdef890 → симуляция",
    "trace_id = ghij123 → трассировка",
    "trace_id = klmn456 → аудит",
  ]}
>
  **Требования:**
  - `type traceKey string; const TraceIDKey traceKey = "trace_id"`
  - `ctx = context.WithValue(ctx, TraceIDKey, id)`
  - в вложенной функции: `id := ctx.Value(TraceIDKey).(string)`
  - логируй через slog: `"Обработка", "trace_id", id`

  Пример вывода:
  ```
  level=INFO msg="Начало обработки" trace_id=abc123
  level=INFO msg="Данные обработаны" trace_id=abc123
  ```
</TaskWithVariants>

## Задание 5 — Итоговое: Параллельный поиск + таймаут + trace_id

<TaskWithVariants
  taskId="context-5-full-search"
  title="Задание 5: Параллельный поиск с trace_id и таймаутом (итоговое)"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="35-50 минут"
  description="Дан trace_id и слайс файлов. Запусти параллельный поиск слова (errgroup + WithTimeout 8s). Передай trace_id через WithValue."
  variants={[
    "trace_id=abc123, 10 файлов, слово: error",
    "trace_id=def456, 20 файлов, слово: timeout",
    "trace_id=ghi789, 30 файлов, слово: failed",
    "trace_id=jkl012, 15 файлов, слово: warning",
    "trace_id=mno345, 25 файлов, слово: success",
    "trace_id=pqr678, 40 файлов, слово: critical",
    "trace_id=stu901, 50 файлов, слово: panic",
    "trace_id=vwx234, 8 файлов, слово: debug",
    "trace_id=yzab567, 12 файлов, слово: info",
    "trace_id=cdef890, 35 файлов, слово: query",
    "trace_id=ghij123, 45 файлов, слово: connection",
    "trace_id=klmn456, 60 файлов, слово: database",
  ]}
>
  **Требования:**
  - `g, ctx := errgroup.WithContext(context.Background())`
  - `ctx = context.WithTimeout(ctx, 8*time.Second)`
  - `ctx = context.WithValue(ctx, TraceIDKey, trace_id)`
  - каждая горутина: чтение файла + поиск слова
  - логируй: `"Поиск", "trace_id", trace_id, "file", filename`
  - если таймаут — первая ошибка DeadlineExceeded

  Пример вывода:
  ```
  level=INFO msg="Начало поиска" trace_id=abc123
  level=INFO msg="Найдено" trace_id=abc123 file=log1.txt
  level=WARN msg="Превышен таймаут" trace_id=abc123
  ```
</TaskWithVariants>

:::tip
Context — это не просто таймаут. Это способ сделать твой код вежливым, отзывчивым и безопасным.  
Всегда передавай ctx первым параметром, проверяй Done() и используй errgroup — это стандарт де-факто в 2026 году.
:::
