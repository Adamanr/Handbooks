---
sidebar_position: 11
description: "Практика по горутинам и каналам в Go: WaitGroup, errgroup, каналы, select, Mutex, sync.Once, Worker Pool, Pipeline, Fan-out/Fan-in"
---

import { RandomVariantButton, TaskWithVariants, CodeBlockGo } from "../../src/components/practicModules/practic";

# Практика: Горутины и каналы

<CodeBlockGo />

## Задание 1 — Параллельная загрузка аватаров

<TaskWithVariants
  taskId="goroutines-1-avatars"
  title="Задание 1: Параллельная загрузка аватаров"
  difficulty={["Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий"]}
  estimatedTime="10-15 минут"
  description="Дан слайс имён пользователей. Запусти горутину для каждого — пусть она «загружает» аватар (имитация: time.Sleep + fmt.Printf). Дождись всех через WaitGroup."
  variants={[
    "Пользователи: alice, bob, charlie, david",
    "Пользователи: maria, ivan, sophia, alex",
    "Пользователи: artem, olga, sergey, katya",
    "Пользователи: max, lena, pavel, nina",
    "Пользователи: julia, dmitry, anna, vlad",
    "Пользователи: elena, nikita, tanya, roman",
    "Пользователи: kira, egor, svetlana, arseniy",
    "Пользователи: mila, timur, vera, kirill",
    "Пользователи: yana, danil, polina, ilya",
    "Пользователи: liza, matvey, sonya, fedor",
    "Пользователи: nastya, georgiy, masha, sasha",
    "Пользователи: rita, lev, anya, denis",
  ]}
>
  **Требования:**
  - функция `downloadAvatar(name string)`
  - `var wg sync.WaitGroup`
  - `wg.Add(1)` перед `go`, `defer wg.Done()` внутри
  - `wg.Wait()` в конце main
  - выведи время начала и завершения каждой загрузки

  Пример вывода:
  ```
  14:35:22 alice: начало загрузки
  14:35:22 bob: начало загрузки
  14:35:23 alice: аватар загружен
  14:35:24 bob: аватар загружен
  Все аватары загружены
  ```
</TaskWithVariants>

## Задание 2 — Параллельный поиск слова в файлах (errgroup)

<TaskWithVariants
  taskId="goroutines-2-errgroup-search"
  title="Задание 2: Параллельный grep с errgroup"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="20-25 минут"
  description="Дан слайс имён файлов и искомое слово. Запусти горутину для каждого файла — ищи слово построчно. Собери первую ошибку через errgroup."
  variants={[
    "Файлы: log1.txt, log2.txt, log3.txt; слово: error",
    "Файлы: notes/*.md; слово: TODO",
    "Файлы: data/*.csv; слово: failed",
    "Файлы: config/*.json; слово: password",
    "Файлы: src/*.go; слово: panic",
    "Файлы: docs/*.txt; слово: deprecated",
    "Файлы: backup/*.log; слово: timeout",
    "Файлы: temp/*.tmp; слово: warning",
    "Файлы: output/*.out; слово: success",
    "Файлы: scripts/*.sh; слово: exit",
    "Файлы: tests/*.test; слово: FAIL",
    "Файлы: queries/*.sql; слово: SELECT",
  ]}
>
  **Требования:**
  - `g := new(errgroup.Group)`
  - `g.Go(func() error { ... })` для каждого файла
  - внутри: `os.Open`, `bufio.Scanner`, поиск слова
  - если файл не найден — вернуть ошибку
  - в конце: `if err := g.Wait(); err != nil { slog.Error("поиск прерван", "err", err) }`

  Пример вывода:
  ```
  log1.txt:12: critical error occurred
  log2.txt:45: connection timeout
  Ошибка: open missing.log: no such file
  ```
</TaskWithVariants>

## Задание 3 — Безопасный счётчик посещений (Mutex)

<TaskWithVariants
  taskId="goroutines-3-counter"
  title="Задание 3: Счётчик посещений сайта"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="15-20 минут"
  description="Создай структуру SiteStats с полем Visits int64. Запусти 1000 горутин — каждая увеличивает счётчик. Используй Mutex или atomic."
  variants={[
    "1000 горутин → ожидается ровно 1000 посещений",
    "5000 горутин → ожидается ровно 5000",
    "10000 горутин → ожидается ровно 10000",
    "100 горутин + RWMutex (только запись)",
    "2000 горутин + atomic.AddInt64",
    "3000 горутин + Mutex",
    "4000 горутин + RWMutex",
    "1500 горутин + atomic",
    "2500 горутин + Mutex",
    "8000 горутин + atomic",
    "12000 горутин → тест производительности",
    "20000 горутин → сравни Mutex vs atomic",
  ]}
>
  **Требования:**
  - два варианта: с `sync.Mutex` и с `sync/atomic`
  - сравни итоговое значение и время выполнения
  - выведи: "Ожидалось 1000, получили X за Y мс"

  Пример вывода:
  ```
  Mutex: ожидалось 1000, получили 1000 за 18 мс
  Atomic: ожидалось 1000, получили 1000 за 4 мс
  ```
</TaskWithVariants>

## Задание 4 — Pipeline обработки логов

<TaskWithVariants
  taskId="goroutines-4-pipeline"
  title="Задание 4: Конвейер обработки логов"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="25-30 минут"
  description="Создай конвейер: 1) генератор логов → 2) фильтр ошибок → 3) форматировщик → 4) вывод. Используй каналы между стадиями."
  variants={[
    "Логи: 100 строк, 20 ошибок → вывести только ошибки",
    "Логи: 500 строк, 50 ошибок → вывести с номером строки",
    "Логи: 1000 строк → найти все timeout",
    "Логи: 200 строк → выделить критические (level=CRITICAL)",
    "Логи: 300 строк → посчитать количество по уровням",
    "Логи: 400 строк → преобразовать timestamp в дату",
    "Логи: 600 строк → отфильтровать по user_id",
    "Логи: 800 строк → найти дубликаты",
    "Логи: 1200 строк → подсветить медленные запросы",
    "Логи: 1500 строк → сгруппировать по IP",
    "Логи: 2000 строк → вывести топ-5 ошибок",
    "Логи: 3000 строк → статистика по минутам",
  ]}
>
  **Требования:**
  - 4 стадии — каждая в своей горутине
  - каналы: `gen → filter → format → print`
  - используй `for line := range in` и `close(out)` в конце стадии

  Пример вывода:
  ```
  [ERROR] 2026-01-07 14:35:22 connection refused
  [ERROR] 2026-01-07 14:35:23 timeout after 5000ms
  ```
</TaskWithVariants>

## Задание 5 — Worker Pool с ограничением параллелизма

<TaskWithVariants
  taskId="goroutines-5-worker-pool"
  title="Задание 5: Worker Pool для парсинга URL"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="30-40 минут"
  description="Дан слайс URL. Ограничи параллелизм до N воркеров (буферизованный канал-семафор). Каждый воркер «скачивает» страницу (имитация). Собери результаты."
  variants={[
    "10 URL, 3 воркера",
    "50 URL, 5 воркеров",
    "100 URL, 10 воркеров",
    "200 URL, 8 воркеров",
    "500 URL, 20 воркеров",
    "20 URL, 2 воркера",
    "80 URL, 4 воркера",
    "150 URL, 6 воркеров",
    "300 URL, 15 воркеров",
    "400 URL, 12 воркеров",
    "600 URL, 25 воркеров",
    "1000 URL, 30 воркеров",
  ]}
>
  **Требования:**
  - канал-семафор: `sem := make(chan struct{}, maxWorkers)`
  - канал результатов: `results := make(chan Result)`
  - каждая горутина: `sem <- struct{}{}; defer func(){ <-sem }()`
  - используй WaitGroup + канал для сбора

  Пример вывода:
  ```
  worker-1: https://example.com → 200 OK (342 ms)
  worker-3: https://google.com → 200 OK (189 ms)
  ```
</TaskWithVariants>

## Задание 6 — Итоговое: Параллельный скрейпер с таймаутом

<TaskWithVariants
  taskId="goroutines-6-scraper"
  title="Задание 6: Параллельный скрейпер страниц (итоговое)"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="40-60 минут"
  description="Дан слайс URL. Запусти воркеры (ограничь параллелизм), каждая горутина делает «запрос» (time.Sleep + случайный статус). Собери результаты через errgroup + контекст с таймаутом 5 секунд."
  variants={[
    "20 URL, 5 воркеров, таймаут 5s",
    "50 URL, 10 воркеров, таймаут 8s",
    "100 URL, 15 воркеров, таймаут 10s",
    "200 URL, 20 воркеров, таймаут 12s",
    "300 URL, 25 воркеров, таймаут 15s",
    "400 URL, 30 воркеров, таймаут 20s",
    "500 URL, 20 воркеров, таймаут 10s",
    "600 URL, 15 воркеров, таймаут 8s",
    "800 URL, 10 воркеров, таймаут 6s",
    "1000 URL, 8 воркеров, таймаут 5s",
    "1200 URL, 5 воркеров, таймаут 4s",
    "1500 URL, 3 воркера, таймаут 3s",
  ]}
>
  **Требования:**
  - `g, ctx := errgroup.WithContext(context.Background())`
  - `ctx, cancel := context.WithTimeout(ctx, 5*time.Second)`
  - `defer cancel()`
  - семафор + errgroup.Go()
  - имитация запроса: случайный sleep 1–10s + статус 200/500/timeout

  Пример вывода:
  ```
  https://site1.com → 200 OK (2.3s)
  https://site2.com → timeout (5.0s)
  Обработка прервана по таймауту
  ```
</TaskWithVariants>

:::tip
Горутины и каналы — это сердце Go.  
Пиши просто, используй WaitGroup/errgroup, каналы вместо блокировок — и твой код будет быстрым, безопасным и понятным.
:::
