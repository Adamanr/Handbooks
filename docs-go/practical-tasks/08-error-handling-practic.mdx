---
sidebar_position: 9
description: "Практика по обработке ошибок и паникам в Go: errors.Is/As, кастомные ошибки, errors.Join, panic/recover, slog"
---

import { RandomVariantButton, TaskWithVariants, CodeBlockGo } from "../../src/components/practicModules/practic";

# Практика: Обработка ошибок и паники

<CodeBlockGo />

## Задание 1 — Безопасный делитель с контекстом

<TaskWithVariants
  taskId="errors-1-safe-divide"
  title="Задание 1: Безопасный делитель"
  difficulty={["Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий","Лёгкий"]}
  estimatedTime="10-15 минут"
  description="Функция SafeDivide(a, b float64) (float64, error). Если b == 0 — верни ошибку с контекстом через fmt.Errorf."
  variants={[
    "10.0 / 2.0 → 5.0",
    "15.5 / 0.0 → ошибка 'деление на ноль'",
    "0.0 / 5.0 → 0.0",
    "-20.0 / 4.0 → -5.0",
    "100.0 / 0.0 → ошибка",
    "7.5 / 3.0 → 2.5",
    "999.9 / 9.9 → 101.0",
    "0.0001 / 0.0 → ошибка",
    "1.0 / 1.0 → 1.0",
    "-1.0 / -2.0 → 0.5",
    "123456.789 / 0.0 → ошибка",
    "0.0 / 0.0 → ошибка",
  ]}
>
  **Требования:**
  - если b == 0 — `return 0, fmt.Errorf("деление %.2f на ноль недопустимо", a)`
  - в main: если err != nil — выведи ошибку красным (или с эмодзи ⚠️)
  - если всё ок — результат с двумя знаками после запятой

  Пример вывода:
  ```
  10.0 / 2.0 = 5.00 ✅
  15.5 / 0.0 → ⚠️ деление 15.50 на ноль недопустимо
  ```
</TaskWithVariants>

## Задание 2 — Валидация возраста с кастомной ошибкой

<TaskWithVariants
  taskId="errors-2-age-validation"
  title="Задание 2: Валидация возраста"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="15-20 минут"
  description="Создай тип AgeError struct { Age int; Message string }. Реализуй Error(). Функция CheckAge(age int) error."
  variants={[
    "age = 25 → успех",
    "age = -5 → AgeError: возраст не может быть отрицательным",
    "age = 200 → AgeError: возраст слишком большой",
    "age = 0 → AgeError",
    "age = 150 → успех",
    "age = 151 → AgeError",
    "age = 18 → успех",
    "age = 1 → успех",
    "age = -100 → AgeError",
    "age = 100 → успех",
    "age = 99 → успех",
    "age = 17 → успех",
  ]}
>
  **Требования:**
  - структура `AgeError { Age int; Message string }`
  - метод `Error() string` → fmt.Sprintf("возраст %d: %s", e.Age, e.Message)
  - проверки: < 0, > 150
  - в main: type assertion `if ae, ok := err.(AgeError); ok { … }`

  Пример вывода:
  ```
  Возраст 25: всё в порядке ✓
  Возраст -5: возраст не может быть отрицательным ✗
  ```
</TaskWithVariants>

## Задание 3 — Множественная валидация (errors.Join)

<TaskWithVariants
  taskId="errors-3-multi-validation"
  title="Задание 3: Множественная валидация пользователя"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="20-25 минут"
  description="Функция ValidateUser(name, email string, age int) error. Собери все ошибки через errors.Join."
  variants={[
    "name=\"Artem\", email=\"a@b.c\", age=28 → успех",
    "name=\"\", email=\"a@b.c\", age=28 → ошибка имени",
    "name=\"Artem\", email=\"invalid\", age=28 → ошибка email",
    "name=\"Artem\", email=\"a@b.c\", age=-5 → ошибка возраста",
    "name=\"\", email=\"invalid\", age=-5 → все три ошибки",
    "name=\" \", email=\"a@b.com\", age=200 → ошибки имени и возраста",
    "name=\"Artem\", email=\"\", age=151 → ошибки email и возраста",
    "name=\"VeryLongName1234567890\", email=\"ok\", age=25 → успех (или лимит длины)",
    "name=\"\", email=\"\", age=0 → три ошибки",
    "name=\"Artem\", email=\"a@b.c\", age=150 → успех",
    "name=\"Artem\", email=\"a@b.c\", age=151 → ошибка возраста",
    "name=\"\", email=\"invalid\", age=0 → все ошибки",
  ]}
>
  **Требования:**
  - проверки: имя не пустое и не только пробелы, email содержит `@`, возраст 0–150
  - собирай ошибки в слайс `[]error`, затем `return errors.Join(errs...)`
  - в main: если err != nil — выведи каждую ошибку отдельной строкой

  Пример вывода:
  ```
  Ошибки валидации:
  имя обязательно
  некорректный email
  возраст должен быть от 0 до 150
  ```
</TaskWithVariants>

## Задание 4 — Паника при критической ошибке

<TaskWithVariants
  taskId="errors-4-panic-recover"
  title="Задание 4: Аварийная остановка ракеты"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="15-20 минут"
  description="Функция LaunchRocket(fuel int). Если топлива < 100 — паника. В main перехвати панику через defer + recover."
  variants={[
    "fuel = 50 → паника поймана",
    "fuel = 200 → успех",
    "fuel = 99 → паника",
    "fuel = 100 → успех",
    "fuel = 0 → паника",
    "fuel = 150 → успех",
    "fuel = -10 → паника",
    "fuel = 500 → успех",
    "fuel = 300 → успех",
    "fuel = 1000 → успех",
    "fuel = 90 → паника",
    "fuel = 120 → успех",
  ]}
>
  **Требования:**
  - `if fuel < 100 { panic("недостаточно топлива") }`
  - в main: `defer func() { if r := recover(); r != nil { fmt.Printf("Авария! %v\nЭкипаж в безопасности", r) } }()`
  - после recover можно продолжить работу (например, "миссия отменена")

  Пример вывода:
  ```
  Запускаем ракету...
  Авария! недостаточно топлива
  Экипаж в безопасности
  Миссия отменена
  ```
</TaskWithVariants>

## Задание 5 — Логгер ошибок с slog

<TaskWithVariants
  taskId="errors-5-slog"
  title="Задание 5: Логгер ошибок с slog"
  difficulty={["Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний","Средний"]}
  estimatedTime="15-20 минут"
  description="Создай глобальный slog-логгер. Пиши в него ошибки с уровнем Error и атрибутами (operation, err)."
  variants={[
    "Ошибка открытия файла",
    "Ошибка чтения конфига",
    "Ошибка валидации",
    "Ошибка сети",
    "Ошибка деления",
    "Ошибка парсинга",
    "Ошибка записи в лог",
    "Ошибка подключения к БД",
    "Ошибка JSON",
    "Ошибка возраста",
    "Ошибка имени",
    "Ошибка email",
  ]}
>
  **Требования:**
  - `slog.SetDefault(slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelInfo})))`
  - функция `LogError(msg string, err error, attrs ...any)`
  - используй `slog.Error(msg, "err", err, attrs...)`
  - в main симулируй 3–5 ошибок

  Пример вывода:
  ```
  time=... level=ERROR msg="не удалось открыть файл" err="open config.json: no such file" operation=load_config
  ```
</TaskWithVariants>

## Задание 6 — Chain of errors (обёртывание)

<TaskWithVariants
  taskId="errors-6-error-chain"
  title="Задание 6: Цепочка ошибок"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="25-35 минут"
  description="Функции: ReadFile → ParseConfig → ValidateConfig. Каждая оборачивает ошибку через %w. В main проверяй errors.Is и errors.As."
  variants={[
    "файл не найден → ошибка на уровне ReadFile",
    "неверный JSON → ошибка на уровне ParseConfig",
    "возраст < 0 → ошибка на уровне ValidateConfig",
    "все три ошибки подряд",
    "файл существует, но пустой → ошибка Parse",
    "файл есть, JSON неверный → ошибка Parse",
    "файл есть, JSON ок, но возраст 200 → ошибка Validate",
    "файл не существует → ошибка Read",
    "файл есть, но права доступа → ошибка Read",
    "файл есть, JSON ок, возраст 25 → успех",
    "файл есть, JSON с лишними полями → успех или ошибка (по желанию)",
    "файл есть, но не JSON → ошибка Parse",
  ]}
>
  **Требования:**
  - `ReadFile(path) ([]byte, error)` → `fmt.Errorf("не удалось прочитать %s: %w", path, err)`
  - `ParseConfig(data []byte) (Config, error)` → `%w`
  - `ValidateConfig(cfg Config) error` → кастомная ошибка или fmt.Errorf
  - в main: `errors.Is(err, os.ErrNotExist)`, `errors.As(err, &target)`

  Пример вывода:
  ```
  Ошибка: не удалось прочитать config.json: open config.json: no such file or directory
  Файл точно не найден
  ```
</TaskWithVariants>

## Задание 7 — Итоговое: Надёжный загрузчик конфига

<TaskWithVariants
  taskId="errors-7-config-loader"
  title="Задание 7: Надёжный загрузчик конфига (итоговое)"
  difficulty={["Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный","Сложный"]}
  estimatedTime="35-50 минут"
  description="Программа загружает config.json. Обрабатывай все возможные ошибки: файл не найден, неверный JSON, невалидные значения. Логируй через slog."
  variants={[
    "файл отсутствует → дефолтные значения",
    "файл есть, но пустой → ошибка",
    "файл есть, JSON неверный → ошибка",
    "файл есть, возраст < 0 → ошибка",
    "файл есть, всё ок → успех",
    "файл есть, лишние поля → успех (если не strict)",
    "файл есть, но права только чтение → ошибка",
    "файл есть, JSON с ошибкой синтаксиса → ошибка",
    "файл есть, возраст 200 → ошибка",
    "файл есть, имя пустое → ошибка",
    "файл есть, email без @ → ошибка",
    "все ошибки по очереди",
  ]}
>
  **Требования:**
  - структура `Config { Name string; Age int; Email string }`
  - функция `LoadConfig(path string) (Config, error)`
  - используй `errors.Is`, `errors.As`, `errors.Join`
  - логируй через `slog.Error` с атрибутами
  - если файл не найден — верни дефолтный конфиг и залогируй Warn

  Пример вывода:
  ```
  WARN Конфиг не найден — использую значения по умолчанию
  Загружен конфиг: {Artem 28 artem@example.com}
  ```
</TaskWithVariants>

:::tip
Ошибки — это не враги, а друзья.  
Проверяй их явно, оборачивай для контекста, логируй через slog — и твой код будет надёжным и понятным.
:::
